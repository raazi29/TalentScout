"""
Language Manager for TalentScout Hiring Assistant.

Handles multilingual support, language detection, and translation.
"""
import re
from typing import Dict, List, Optional, Tuple, Any
import json
import os

class LanguageManager:
    """Manages multilingual support for the TalentScout chatbot."""
    
    # Supported languages with their codes and names
    SUPPORTED_LANGUAGES = {
        "en": {
            "name": "English",
            "native_name": "English",
            "flag": "ЁЯЗ║ЁЯЗ╕"
        },
        "es": {
            "name": "Spanish",
            "native_name": "Espa├▒ol",
            "flag": "ЁЯЗкЁЯЗ╕"
        },
        "fr": {
            "name": "French",
            "native_name": "Fran├зais",
            "flag": "ЁЯЗлЁЯЗ╖"
        },
        "de": {
            "name": "German",
            "native_name": "Deutsch",
            "flag": "ЁЯЗйЁЯЗк"
        },
        "it": {
            "name": "Italian",
            "native_name": "Italiano",
            "flag": "ЁЯЗоЁЯЗ╣"
        },
        "pt": {
            "name": "Portuguese",
            "native_name": "Portugu├кs",
            "flag": "ЁЯЗ╡ЁЯЗ╣"
        },
        "ru": {
            "name": "Russian",
            "native_name": "╨а╤Г╤Б╤Б╨║╨╕╨╣",
            "flag": "ЁЯЗ╖ЁЯЗ║"
        },
        "zh": {
            "name": "Chinese",
            "native_name": "ф╕нцЦЗ",
            "flag": "ЁЯЗиЁЯЗ│"
        },
        "ja": {
            "name": "Japanese",
            "native_name": "цЧецЬмшкЮ",
            "flag": "ЁЯЗпЁЯЗ╡"
        },
        "ko": {
            "name": "Korean",
            "native_name": "эХЬъ╡ньЦ┤",
            "flag": "ЁЯЗ░ЁЯЗ╖"
        },
        "hi": {
            "name": "Hindi",
            "native_name": "рд╣рд┐рдиреНрджреА",
            "flag": "ЁЯЗоЁЯЗ│"
        },
        "bn": {
            "name": "Bengali",
            "native_name": "ржмрж╛ржВрж▓рж╛",
            "flag": "ЁЯЗоЁЯЗ│"
        },
        "ta": {
            "name": "Tamil",
            "native_name": "родрооро┐ро┤рпН",
            "flag": "ЁЯЗоЁЯЗ│"
        },
        "te": {
            "name": "Telugu",
            "native_name": "р░др▒Жр░▓р▒Бр░Чр▒Б",
            "flag": "ЁЯЗоЁЯЗ│"
        },
        "mr": {
            "name": "Marathi",
            "native_name": "рдорд░рд╛рдареА",
            "flag": "ЁЯЗоЁЯЗ│"
        },
        "gu": {
            "name": "Gujarati",
            "native_name": "ркЧрлБркЬрк░рк╛ркдрлА",
            "flag": "ЁЯЗоЁЯЗ│"
        },
        "kn": {
            "name": "Kannada",
            "native_name": "р▓Хр▓ир│Нр▓ир▓б",
            "flag": "ЁЯЗоЁЯЗ│"
        },
        "ml": {
            "name": "Malayalam",
            "native_name": "р┤ор┤▓р┤пр┤╛р┤│р┤В",
            "flag": "ЁЯЗоЁЯЗ│"
        },
        "pa": {
            "name": "Punjabi",
            "native_name": "рикрй░риЬри╛римрйА",
            "flag": "ЁЯЗоЁЯЗ│"
        },
        "ur": {
            "name": "Urdu",
            "native_name": "╪з╪▒╪п┘И",
            "flag": "ЁЯЗоЁЯЗ│"
        },
        "ar": {
            "name": "Arabic",
            "native_name": "╪з┘Д╪╣╪▒╪и┘К╪й",
            "flag": "ЁЯЗ╕ЁЯЗж"
        }
    }
    
    # Language detection patterns
    LANGUAGE_PATTERNS = {
        "en": [
            r"\b(hello|hi|hey|good|morning|afternoon|evening|name|email|phone|experience|years|position|location|tech|stack|programming|language|framework|database|cloud|tool)\b",
            r"\b(thank|you|please|help|assist|interview|candidate|recruitment|job|career|skill|technology)\b"
        ],
        "es": [
            r"\b(hola|buenos|d├нas|tardes|noches|nombre|correo|tel├йfono|experiencia|a├▒os|posici├│n|ubicaci├│n|tecnolog├нa|programaci├│n|lenguaje|marco|base|datos|nube|herramienta)\b",
            r"\b(gracias|por|favor|ayuda|asistir|entrevista|candidato|reclutamiento|trabajo|carrera|habilidad)\b"
        ],
        "fr": [
            r"\b(bonjour|salut|bon|matin|apr├иs-midi|soir|nom|email|t├йl├йphone|exp├йrience|ann├йes|poste|localisation|technologie|programmation|langage|cadre|base|donn├йes|nuage|outil)\b",
            r"\b(merci|s'il|vous|pla├оt|aider|assister|entretien|candidat|recrutement|travail|carri├иre|comp├йtence)\b"
        ],
        "de": [
            r"\b(hallo|guten|morgen|tag|abend|name|email|telefon|erfahrung|jahre|position|standort|technologie|programmierung|sprache|rahmen|datenbank|wolke|werkzeug)\b",
            r"\b(danke|bitte|helfen|unterst├╝tzen|interview|kandidat|rekrutierung|arbeit|karriere|f├дhigkeit)\b"
        ],
        "it": [
            r"\b(ciao|buongiorno|buonasera|nome|email|telefono|esperienza|anni|posizione|localit├а|tecnologia|programmazione|linguaggio|framework|database|cloud|strumento)\b",
            r"\b(grazie|per|favore|aiutare|assistere|intervista|candidato|reclutamento|lavoro|carriera|abilit├а)\b"
        ],
        "pt": [
            r"\b(ol├б|bom|dia|tarde|noite|nome|email|telefone|experi├кncia|anos|posi├з├гo|localiza├з├гo|tecnologia|programa├з├гo|linguagem|framework|banco|dados|nuvem|ferramenta)\b",
            r"\b(obrigado|por|favor|ajudar|assistir|entrevista|candidato|recrutamento|trabalho|carreira|habilidade)\b"
        ],
        "ru": [
            r"\b(╨┐╤А╨╕╨▓╨╡╤В|╨╖╨┤╤А╨░╨▓╤Б╤В╨▓╤Г╨╣╤В╨╡|╨┤╨╛╨▒╤А╤Л╨╣|╤Г╤В╤А╨╛|╨┤╨╡╨╜╤М|╨▓╨╡╤З╨╡╤А|╨╕╨╝╤П|╨┐╨╛╤З╤В╨░|╤В╨╡╨╗╨╡╤Д╨╛╨╜|╨╛╨┐╤Л╤В|╨│╨╛╨┤╤Л|╨┐╨╛╨╖╨╕╤Ж╨╕╤П|╨╝╨╡╤Б╤В╨╛╨┐╨╛╨╗╨╛╨╢╨╡╨╜╨╕╨╡|╤В╨╡╤Е╨╜╨╛╨╗╨╛╨│╨╕╤П|╨┐╤А╨╛╨│╤А╨░╨╝╨╝╨╕╤А╨╛╨▓╨░╨╜╨╕╨╡|╤П╨╖╤Л╨║|╤Д╤А╨╡╨╣╨╝╨▓╨╛╤А╨║|╨▒╨░╨╖╨░|╨┤╨░╨╜╨╜╤Л╤Е|╨╛╨▒╨╗╨░╨║╨╛|╨╕╨╜╤Б╤В╤А╤Г╨╝╨╡╨╜╤В)\b",
            r"\b(╤Б╨┐╨░╤Б╨╕╨▒╨╛|╨┐╨╛╨╢╨░╨╗╤Г╨╣╤Б╤В╨░|╨┐╨╛╨╝╨╛╤З╤М|╨┐╨╛╨╝╨╛╤Й╤М|╤Б╨╛╨▒╨╡╤Б╨╡╨┤╨╛╨▓╨░╨╜╨╕╨╡|╨║╨░╨╜╨┤╨╕╨┤╨░╤В|╤А╨╡╨║╤А╤Г╤В╨╕╨╜╨│|╤А╨░╨▒╨╛╤В╨░|╨║╨░╤А╤М╨╡╤А╨░|╨╜╨░╨▓╤Л╨║)\b"
        ],
        "zh": [
            r"\b(ф╜ахе╜|цЧйф╕Кхе╜|ф╕ЛхНИхе╜|цЩЪф╕Кхе╜|хзУхРН|щВочо▒|чФ╡шпЭ|ч╗ПщкМ|х╣┤|шБМф╜Н|ф╜Нч╜о|цКАцЬп|ч╝ЦчиЛ|шпншиА|цбЖцЮ╢|цХ░цНох║У|ф║С|х╖ехЕ╖)\b",
            r"\b(ш░вш░в|шп╖|х╕охКй|хНПхКй|щЭвшпХ|хАЩщАЙф║║|цЛЫшБШ|х╖еф╜Ь|шБМф╕Ъ|цКАшГ╜)\b"
        ],
        "ja": [
            r"\b(уБУуВУуБлуБбуБп|уБКуБпуВИуБЖ|уБУуВУуБ░уВУуБп|хРНхЙН|уГбуГ╝уГл|щЫ╗шй▒|ч╡МщиУ|х╣┤|шБ╖ф╜Н|ха┤цЙА|цКАшбУ|уГЧуГнуВ░уГйуГЯуГ│уВ░|шиАшкЮ|уГХуГмуГ╝уГауГпуГ╝уВп|уГЗуГ╝уВ┐уГЩуГ╝уВ╣|уВпуГйуВжуГЙ|уГДуГ╝уГл)\b",
            r"\b(уБВуВКуБМуБиуБЖ|уБКщбШуБД|хКйуБСуВЛ|цФпцП┤|щЭвцОе|хАЩшгЬшАЕ|цОбчФи|ф╗Хф║Л|уВнуГгуГкуВв|уВ╣уВнуГл)\b"
        ],
        "ko": [
            r"\b(ьХИыЕХэХШьД╕ьЪФ|ьвЛьЭА|ьХДь╣и|ьШдэЫД|ьаАыЕБ|ьЭ┤ыжД|ьЭ┤ыйФьЭ╝|ьаДэЩФ|ъ▓╜эЧШ|ыЕД|ьзБьЬД|ьЬДь╣Ш|ъ╕░ьИа|эФДыбЬъ╖╕ыЮШы░Н|ьЦ╕ьЦ┤|эФДыаИьЮДьЫМэБм|ыН░ьЭ┤эД░ы▓аьЭ┤ьКд|эБ┤ыЭ╝ьЪ░ыУЬ|ыПДъ╡м)\b",
            r"\b(ъ░РьВмэХйыЛИыЛд|ы╢АэГБ|ыПДьЫА|ьзАьЫР|ый┤ьаС|эЫДы│┤ьЮР|ь▒ДьЪй|ьЭ╝|ъ▓╜ыае|ъ╕░ьИа)\b"
        ],
        "hi": [
            r"\b(рдирдорд╕реНрддреЗ|рд╕реБрдкреНрд░рднрд╛рдд|рд╢реБрдн|рджреЛрдкрд╣рд░|рд╢рд╛рдо|рдирд╛рдо|рдИрдореЗрд▓|рдлреЛрди|рдЕрдиреБрднрд╡|рд╕рд╛рд▓|рдкрдж|рд╕реНрдерд╛рди|рддрдХрдиреАрдХ|рдкреНрд░реЛрдЧреНрд░рд╛рдорд┐рдВрдЧ|рднрд╛рд╖рд╛|рдлреНрд░реЗрдорд╡рд░реНрдХ|рдбреЗрдЯрд╛рдмреЗрд╕|рдХреНрд▓рд╛рдЙрдб|рдЙрдкрдХрд░рдг)\b",
            r"\b(рдзрдиреНрдпрд╡рд╛рдж|рдХреГрдкрдпрд╛|рдорджрдж|рд╕рд╣рд╛рдпрддрд╛|рд╕рд╛рдХреНрд╖рд╛рддреНрдХрд╛рд░|рдЙрдореНрдореАрджрд╡рд╛рд░|рднрд░реНрддреА|рдХрд╛рдо|рдХрд░рд┐рдпрд░|рдХреМрд╢рд▓)\b"
        ],
        "bn": [
            r"\b(ржиржорж╕рзНржХрж╛рж░|рж╢рзБржн|рж╕ржХрж╛рж▓|ржжрзБрикри╣ри┐ри░|рж╕рж╛ржБржБриЬ|ржирж╛ржБржо|ржЗржорзЗржЗрж▓|ржлрзЛржБржи|ржЕржнрж┐ржЬрзНржЮрждрж╛|ржмржЫрж░|ржкржж|рж╕рзНржерж╛ржи|ржкрзНрж░ржпрзБржХрзНрждрж┐|ржкрзНрж░рзЛржЧрзНрж░рж╛ржорж┐ржВ|ржнрж╛рж╖рж╛|ржлрзНрж░рзЗржоржУржпрж╝рж╛рж░рзНржХ|ржбрж╛ржЯрж╛ржмрзЗрж╕|ржХрзНрж▓рж╛ржЙржб|рж╕рж░ржЮрзНржЬрж╛ржо)\b",
            r"\b(ржзржирзНржпржмрж╛ржж|ржЕржирзБржЧрзНрж░рж╣|рж╕рж╛рж╣рж╛ржпрзНржп|рж╕рж╣рж╛ржпрж╝рждрж╛|рж╕рж╛ржХрзНрж╖рж╛рзОржХрж╛рж░|ржкрзНрж░рж╛рж░рзНржерзА|ржирж┐ржпрж╝рзЛржЧ|ржХрж╛ржЬ|ржХрзНржпрж╛рж░рж┐ржпрж╝рж╛рж░|ржжржХрзНрж╖рждрж╛)\b"
        ],
        "ta": [
            r"\b(ро╡рогроХрпНроХроорпН|роХро╛ро▓рпИ|роородро┐ропроорпН|рооро╛ро▓рпИ|рокрпЖропро░рпН|рооро┐ройрпНройроЮрпНроЪро▓рпН|родрпКро▓рпИрокрпЗроЪро┐|роЕройрпБрокро╡роорпН|роЖрогрпНроЯрпБроХро│рпН|рокродро╡ро┐|роЗроЯроорпН|родрпКро┤ро┐ро▓рпНроирпБроЯрпНрокроорпН|роиро┐ро░ро▓ро╛роХрпНроХроорпН|роорпКро┤ро┐|роХроЯрпНроЯроорпИрокрпНрокрпБ|родро░ро╡рпБродрпНродро│роорпН|роорпЗроХроорпН|роХро░рпБро╡ро┐|роОройрпНрой|роЙроЩрпНроХро│рпН|роОройрпН|роиро╛ройрпН)\b",
            r"\b(роиройрпНро▒ро┐|родропро╡рпБроЪрпЖропрпНродрпБ|роЙродро╡ро┐|роЖродро░ро╡рпБ|роирпЗро░рпНроХро╛рогро▓рпН|ро╡ро┐рогрпНрогрокрпНрокродро╛ро░ро░рпН|рооройро┐родро╡ро│роорпН|ро╡рпЗро▓рпИ|ро╡ро╛ро┤рпНроХрпНроХрпИ|родро┐ро▒роорпИ|роХрпЗро│рпНро╡ро┐|рокродро┐ро▓рпН)\b"
        ],
        "te": [
            r"\b(р░ир░ор░╕р▒Нр░Хр░╛р░░р░В|р░╢р▒Бр░нр▒Лр░жр░пр░В|р░╢р▒Бр░н|р░ор░зр▒Нр░пр░╛р░╣р▒Нр░ир░В|р░╕р░╛р░пр░Вр░др▒Нр░░р░В|р░кр▒Зр░░р▒Б|р░Зр░ор▒Жр░пр░┐р░▓р▒Н|р░лр▒Лр░ир▒Н|р░Ер░ир▒Бр░нр░╡р░В|р░╕р░Вр░╡р░др▒Нр░╕р░░р░╛р░▓р▒Б|р░кр░жр░╡р░┐|р░╕р▒Нр░ер░╛р░ир░В|р░Яр▒Жр░Хр▒Нр░ир░╛р░▓р░Ьр▒А|р░кр▒Нр░░р▒Лр░Чр▒Нр░░р░╛р░ор░┐р░Вр░Чр▒Н|р░нр░╛р░╖|р░лр▒Нр░░р▒Зр░ор▒НтАМр░╡р░░р▒Нр░Хр▒Н|р░бр▒Зр░Яр░╛р░мр▒Зр░╕р▒Н|р░Хр▒Нр░▓р▒Мр░бр▒Н|р░╕р░╛р░зр░ир░В|р░Пр░ор░┐р░Яр░┐|р░ор▒А|р░ир░╛|р░ир▒Зр░ир▒Б)\b",
            r"\b(р░зр░ир▒Нр░пр░╡р░╛р░жр░╛р░▓р▒Б|р░жр░пр░Ър▒Зр░╕р░┐|р░╕р░╣р░╛р░пр░В|р░ор░жр▒Нр░жр░др▒Б|р░Зр░Вр░Яр░░р▒Нр░╡р▒Нр░пр▒В|р░Ер░нр▒Нр░пр░░р▒Нр░ер░┐|р░ир░┐р░пр░╛р░ор░Хр░╛р░др░┐|р░Хр▒Жр░▓р░╕|р░╡р▒Гр░др▒Нр░др░┐|р░Хр▒Мр░╢р░▓р▒Нр░п|р░кр▒Нр░░р░╢р▒Нр░и|р░╕р░ор░╛р░зр░╛р░ир░В)\b"
        ],
        "mr": [
            r"\b(рдирдорд╕реНрдХрд╛рд░|рд╕реБрдкреНрд░рднрд╛рдд|рд╢реБрдн|рджреБрдкрд╛рд░|рд╕рдВрдзреНрдпрд╛рдХрд╛рд│|рдирд╛рд╡|рдИрдореЗрд▓|рдлреЛрди|рдЕрдиреБрднрд╡|рд╡рд░реНрд╖реЗ|рдкрдж|рд╕реНрдерд╛рди|рддрдВрддреНрд░рдЬреНрдЮрд╛рди|рдкреНрд░реЛрдЧреНрд░рд╛рдорд┐рдВрдЧ|рднрд╛рд╖рд╛|рдлреНрд░реЗрдорд╡рд░реНрдХ|рдбреЗрдЯрд╛рдмреЗрд╕|рдХреНрд▓рд╛рдЙрдб|рд╕рд╛рдзрди)\b",
            r"\b(рдзрдиреНрдпрд╡рд╛рдж|рдХреГрдкрдпрд╛|рдорджрдд|рд╕рд╣рд╛рдпреНрдп|рдореБрд▓рд╛рдЦрдд|рдЙрдореЗрджрд╡рд╛рд░|рднрд░рддреА|рдХрд╛рдо|рдХрд░рд┐рдЕрд░|рдХреМрд╢рд▓реНрдп)\b"
        ],
        "gu": [
            r"\b(ркиркорк╕рлНркдрлЗ|рк╕рлБрккрлНрк░ркнрк╛ркд|рк╢рлБркн|ркмрккрлЛрк░|рк╕рк╛ркВркЬ|ркирк╛рко|ркИркорлЗрк▓|рклрлЛрки|ркЕркирлБркнрк╡|рк╡рк░рлНрк╖|рккркж|рк╕рлНркерк╛рки|ркЯрлЗркХркирлЛрк▓рлЛркЬрлА|рккрлНрк░рлЛркЧрлНрк░рк╛ркорк┐ркВркЧ|ркнрк╛рк╖рк╛|рклрлНрк░рлЗркорк╡рк░рлНркХ|ркбрлЗркЯрк╛ркмрлЗрк╕|ркХрлНрк▓рк╛ркЙркб|рк╕рк╛ркзрки|рк╢рлБркВ|ркдркорк╛рк░рлБркВ|ркорк╛рк░рлБркВ|рк╣рлБркВ)\b",
            r"\b(ркзркирлНркпрк╡рк╛ркж|ркХрлГрккрк╛|ркоркжркж|рк╕рк╣рк╛ркп|ркЗркирлНркЯрк░рк╡рлНркпрлВ|ркЙркорлЗркжрк╡рк╛рк░|ркнрк░ркдрлА|ркХрк╛рко|ркХрк╛рк░ркХрк┐рк░рлНркжрлА|ркХрлМрк╢рк▓рлНркп|рккрлНрк░рк╢рлНрки|ркЬрк╡рк╛ркм)\b"
        ],
        "kn": [
            r"\b(р▓ир▓ор▓╕р│Нр▓Хр▓╛р▓░|р▓╢р│Бр▓нр│Лр▓жр▓п|р▓╢р│Бр▓н|р▓ор▓зр│Нр▓пр▓╛р▓╣р│Нр▓и|р▓╕р▓Вр▓Ьр│Ж|р▓╣р│Жр▓╕р▓░р│Б|р▓Зр▓ор│Зр▓▓р│Н|р▓лр│Лр▓ир│Н|р▓Ер▓ир│Бр▓нр▓╡|р▓╡р▓░р│Нр▓╖р▓Чр▓│р│Б|р▓╣р│Бр▓жр│Нр▓жр│Ж|р▓╕р│Нр▓ер▓│|р▓др▓Вр▓др│Нр▓░р▓Ьр│Нр▓Юр▓╛р▓и|р▓кр│Нр▓░р│Лр▓Чр│Нр▓░р▓╛р▓ор▓┐р▓Вр▓Чр│Н|р▓нр▓╛р▓╖р│Ж|р▓лр│Нр▓░р│Зр▓ор│НтАМр▓╡р▓░р│Нр▓Хр│Н|р▓бр│Зр▓Яр▓╛р▓мр│Зр▓╕р│Н|р▓ор│Лр▓б|р▓Йр▓кр▓Хр▓░р▓г)\b",
            r"\b(р▓зр▓ир│Нр▓пр▓╡р▓╛р▓ж|р▓жр▓пр▓╡р▓┐р▓Яр│Нр▓Яр│Б|р▓╕р▓╣р▓╛р▓п|р▓мр│Жр▓Вр▓мр▓▓|р▓╕р▓Вр▓жр▓░р│Нр▓╢р▓и|р▓Ер▓нр│Нр▓пр▓░р│Нр▓ер▓┐|р▓ир│Зр▓ор▓Хр▓╛р▓др▓┐|р▓Хр│Жр▓▓р▓╕|р▓╡р│Гр▓др│Нр▓др▓┐|р▓Хр│Мр▓╢р▓▓р│Нр▓п)\b"
        ],
        "ml": [
            r"\b(р┤ир┤ор┤╕р╡Нр┤Хр┤╛р┤░р┤В|р┤╕р╡Бр┤кр╡Нр┤░р┤нр┤╛р┤др┤В|р┤╢р╡Бр┤н|р┤Йр┤Ър╡Нр┤Ъ|р┤╡р╡Ир┤Хр╡Бр┤ир╡Нр┤ир╡Зр┤░р┤В|р┤кр╡Зр┤░р╡Н|р┤Зр┤ор╡Жр┤пр┤┐р╡╜|р┤лр╡Лр╡║|р┤Ер┤ир╡Бр┤нр┤╡р┤В|р┤╡р╡╝р┤╖р┤Щр╡Нр┤Щр╡╛|р┤╕р╡Нр┤ер┤╛р┤ир┤В|р┤╕р╡Нр┤ер┤▓р┤В|р┤╕р┤╛р┤Щр╡Нр┤Хр╡Зр┤др┤┐р┤Хр┤╡р┤┐р┤жр╡Нр┤п|р┤кр╡Нр┤░р╡Лр┤Чр╡Нр┤░р┤╛р┤ор┤┐р┤Вр┤Чр╡Н|р┤нр┤╛р┤╖|р┤лр╡Нр┤░р╡Жр┤пр┤┐р┤Вр┤╡р╡╝р┤Хр╡Нр┤Хр╡Н|р┤бр┤╛р┤▒р╡Нр┤▒р┤╛р┤мр╡Зр┤╕р╡Н|р┤ор╡Зр┤Шр┤В|р┤Йр┤кр┤Хр┤░р┤гр┤В|р┤Ор┤ир╡Нр┤др┤╛р┤гр╡Н|р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж|р┤Ор┤ир╡Нр┤▒р╡Ж|р┤Юр┤╛р╡╗)\b",
            r"\b(р┤ир┤ир╡Нр┤жр┤┐|р┤жр┤пр┤╡р┤╛р┤пр┤┐|р┤╕р┤╣р┤╛р┤пр┤В|р┤кр┤┐р┤ир╡Нр┤др╡Бр┤г|р┤Зр┤ир╡Нр┤▒р╡╝р┤╡р╡Нр┤пр╡В|р┤Ер┤нр╡Нр┤пр╡╝р┤др╡Нр┤ер┤┐|р┤ир┤┐р┤пр┤ор┤ир┤В|р┤Ьр╡Лр┤▓р┤┐|р┤Хр┤░р┤┐р┤пр╡╝|р┤Хр┤┤р┤┐р┤╡р╡Н|р┤Ър╡Лр┤жр╡Нр┤пр┤В|р┤Йр┤др╡Нр┤др┤░р┤В)\b"
        ],
        "pa": [
            r"\b(ри╕рид ри╕рйНри░рйА риЕриХри╛ри▓|ри╕ри╝рйБрин|ри╕ри╡рйЗри░рйЗ|рижрйБрикри╣ри┐ри░|ри╕ри╝ри╛рио|риири╛рио|риИриорйЗри▓|рилрйЛрии|риЕриирйБринри╡|ри╕ри╛ри▓|рикриж|ри╕риери╛рии|риЯрйИриХриири╛ри▓рйЛриЬрйА|рикрйНри░рйЛриЧри░ри╛риори┐рй░риЧ|ринри╛ри╕ри╝ри╛|рилри░рйЗриори╡ри░риХ|рибрйЗриЯри╛римрйЗри╕|риХри▓ри╛риКриб|ри╕ри╛ризрии)\b",
            r"\b(ризрй░риири╡ри╛риж|риХри┐ри░рикри╛|риорижриж|ри╕ри╣ри╛риЗридри╛|риЗрй░риЯри░ри╡ри┐риК|риЙриорйАрижри╡ри╛ри░|ринри░ридрйА|риХрй░рио|риХри░рйАриЕри░|риХрйМри╕ри╝ри▓)\b"
        ],
        "ur": [
            r"\b(╪з┘Д╪│┘Д╪з┘Е ╪╣┘Д█М┌й┘Е|╪╡╪и╪н ╪и╪о█М╪▒|╪┤╪з┘Е ╪и╪о█М╪▒|┘Ж╪з┘Е|╪з█М ┘Е█М┘Д|┘Б┘И┘Ж|╪к╪м╪▒╪и█Б|╪│╪з┘Д|╪╣█Б╪п█Б|┘Е┘В╪з┘Е|┘╣█М┌й┘Ж╪з┘Д┘И╪м█М|┘╛╪▒┘И┌п╪▒╪з┘Е┘Ж┌п|╪▓╪и╪з┘Ж|┘Б╪▒█М┘Е ┘И╪▒┌й|┌И█М┘╣╪з ╪и█М╪│|┌й┘Д╪з╪д┌И|╪в┘Д█Б)\b",
            r"\b(╪┤┌й╪▒█М█Б|╪и╪▒╪з█Б ┌й╪▒┘Е|┘Е╪п╪п|╪н┘Е╪з█М╪к|╪з┘Ж┘╣╪▒┘И█М┘И|╪з┘Е█М╪п┘И╪з╪▒|╪и┌╛╪▒╪к█М|┌й╪з┘Е|┌й█М╪▒█М╪ж╪▒|┘Е█Б╪з╪▒╪к)\b"
        ],
        "ar": [
            r"\b(┘Е╪▒╪н╪и╪з|╪╡╪и╪з╪н|╪з┘Д╪о┘К╪▒|┘Е╪│╪з╪б|╪з┘Д╪о┘К╪▒|╪з╪│┘Е|╪и╪▒┘К╪п|╪е┘Д┘Г╪к╪▒┘И┘Ж┘К|┘З╪з╪к┘Б|╪о╪и╪▒╪й|╪│┘Ж┘И╪з╪к|┘Е┘Ж╪╡╪и|┘Е┘И┘В╪╣|╪к┘В┘Ж┘К╪й|╪и╪▒┘Е╪м╪й|┘Д╪║╪й|╪е╪╖╪з╪▒|╪╣┘Е┘Д|┘В╪з╪╣╪п╪й|╪и┘К╪з┘Ж╪з╪к|╪│╪н╪з╪и╪й|╪г╪п╪з╪й)\b",
            r"\b(╪┤┘Г╪▒╪з|┘Е┘Ж|┘Б╪╢┘Д┘Г|┘Е╪│╪з╪╣╪п╪й|╪п╪╣┘Е|┘Е┘В╪з╪и┘Д╪й|┘Е╪▒╪┤╪н|╪к┘И╪╕┘К┘Б|╪╣┘Е┘Д|┘Е┘З┘Ж╪й|┘Е┘З╪з╪▒╪й)\b"
        ]
    }
    
    def __init__(self):
        """Initialize the language manager."""
        self.current_language = "en"
        self.detected_languages = {}
        self.language_preferences = {}
        
    def detect_language(self, text: str) -> str:
        """
        Detect the language of the input text.
        
        Args:
            text: Input text to analyze
            
        Returns:
            Language code (e.g., 'en', 'es', 'fr')
        """
        # Use the enhanced detection method but return only the language code for backward compatibility
        language, _ = self.detect_language_with_confidence(text)
        return language
    
    def detect_language_with_confidence(self, text: str) -> Tuple[str, float]:
        """
        Detect the language of the input text with confidence scoring.
        
        Args:
            text: Input text to analyze
            
        Returns:
            Tuple of (language_code, confidence_score) where confidence is between 0.0 and 1.0
        """
        if not text or not text.strip():
            return "en", 0.0
            
        text_lower = text.lower().strip()
        text_length = len(text_lower.split())
        
        # If text is too short, confidence will be lower
        length_factor = min(1.0, text_length / 5.0)  # Full confidence at 5+ words
        
        language_scores = {}
        total_matches = 0
        
        # Score each language based on pattern matches
        for lang_code, patterns in self.LANGUAGE_PATTERNS.items():
            score = 0
            unique_matches = set()
            
            for pattern in patterns:
                matches = re.findall(pattern, text_lower, re.IGNORECASE)
                # Count unique matches to avoid over-scoring repeated words
                for match in matches:
                    unique_matches.add(match)
            
            score = len(unique_matches)
            language_scores[lang_code] = score
            total_matches += score
        
        if not language_scores or total_matches == 0:
            return "en", 0.0
        
        # Find the language with the highest score
        detected_lang = max(language_scores, key=language_scores.get)
        max_score = language_scores[detected_lang]
        
        if max_score == 0:
            return "en", 0.0
        
        # Calculate confidence based on:
        # 1. Ratio of max score to total matches (dominance)
        # 2. Absolute score (strength of detection)
        # 3. Text length factor
        dominance_factor = max_score / total_matches if total_matches > 0 else 0
        strength_factor = min(1.0, max_score / 3.0)  # Full strength at 3+ unique matches
        
        # Combine factors for final confidence
        confidence = dominance_factor * strength_factor * length_factor
        
        # Apply minimum confidence threshold
        if confidence < 0.1:
            return "en", 0.0
        
        return detected_lang, min(1.0, confidence)
    
    def set_language(self, language_code: str) -> bool:
        """
        Set the current language for the conversation.
        
        Args:
            language_code: Language code to set
            
        Returns:
            True if language is supported, False otherwise
        """
        if language_code in self.SUPPORTED_LANGUAGES:
            self.current_language = language_code
            return True
        return False
    
    def get_language_info(self, language_code: str) -> Optional[Dict]:
        """
        Get information about a specific language.
        
        Args:
            language_code: Language code
            
        Returns:
            Language information dictionary or None if not found
        """
        return self.SUPPORTED_LANGUAGES.get(language_code)
    
    def get_supported_languages(self) -> Dict:
        """
        Get all supported languages.
        
        Returns:
            Dictionary of supported languages
        """
        return self.SUPPORTED_LANGUAGES
    
    def translate_prompt(self, prompt: str, target_language: str) -> str:
        """
        Translate a prompt to the target language.
        
        Args:
            prompt: Original prompt in English
            target_language: Target language code
            
        Returns:
            Translated prompt
        """
        if target_language == "en":
            return prompt
        
        # Add translation instruction to the prompt
        translation_instruction = f"""
        Please translate the following text to {self.SUPPORTED_LANGUAGES[target_language]['name']} ({target_language}).
        Maintain the professional tone and technical accuracy of the original text.
        
        Original text:
        {prompt}
        
        Translation:
        """
        
        return translation_instruction
    
    def get_localized_greeting(self, language_code: str) -> str:
        """
        Get a localized greeting for the specified language.
        
        Args:
            language_code: Language code
            
        Returns:
            Localized greeting
        """
        greetings = {
            "en": "Hello! Welcome to TalentScout. I'm here to help you with your initial screening interview.",
            "es": "┬бHola! Bienvenido a TalentScout. Estoy aqu├н para ayudarte con tu entrevista de preselecci├│n inicial.",
            "fr": "Bonjour ! Bienvenue chez TalentScout. Je suis ici pour vous aider avec votre entretien de pr├йs├йlection initial.",
            "de": "Hallo! Willkommen bei TalentScout. Ich bin hier, um Ihnen bei Ihrem ersten Vorstellungsgespr├дch zu helfen.",
            "it": "Ciao! Benvenuto in TalentScout. Sono qui per aiutarti con la tua intervista di preselezione iniziale.",
            "pt": "Ol├б! Bem-vindo ao TalentScout. Estou aqui para ajud├б-lo com sua entrevista de triagem inicial.",
            "ru": "╨Я╤А╨╕╨▓╨╡╤В! ╨Ф╨╛╨▒╤А╨╛ ╨┐╨╛╨╢╨░╨╗╨╛╨▓╨░╤В╤М ╨▓ TalentScout. ╨п ╨╖╨┤╨╡╤Б╤М, ╤З╤В╨╛╨▒╤Л ╨┐╨╛╨╝╨╛╤З╤М ╨▓╨░╨╝ ╤Б ╨┐╨╡╤А╨▓╨╛╨╜╨░╤З╨░╨╗╤М╨╜╤Л╨╝ ╤Б╨╛╨▒╨╡╤Б╨╡╨┤╨╛╨▓╨░╨╜╨╕╨╡╨╝.",
            "zh": "ф╜ахе╜я╝Бцмвш┐ОцЭехИ░TalentScoutуАВцИСхЬиш┐ЩщЗМх╕охКйцВиш┐ЫшбМхИЭцнечнЫщАЙщЭвшпХуАВ",
            "ja": "уБУуВУуБлуБбуБпя╝БTalentScoutуБ╕уВИуБЖуБУуБЭуАВхИЭхЫЮщЭвцОеуБоуБКцЙЛф╝ЭуБДуВТуБХуБЫуБжуБДуБЯуБауБНуБ╛уБЩуАВ",
            "ko": "ьХИыЕХэХШьД╕ьЪФ! TalentScoutьЧР ьШдьЛа ъ▓ГьЭД эЩШьШБэХйыЛИыЛд. ь┤Иъ╕░ ьДаы│Д ый┤ьаСьЭД ыПДьЩАыУЬыжмъ▓аьК╡ыЛИыЛд.",
            "hi": "рдирдорд╕реНрддреЗ! TalentScout рдореЗрдВ рдЖрдкрдХрд╛ рд╕реНрд╡рд╛рдЧрдд рд╣реИред рдореИрдВ рдЖрдкрдХреА рдкреНрд░рд╛рд░рдВрднрд┐рдХ рд╕реНрдХреНрд░реАрдирд┐рдВрдЧ рд╕рд╛рдХреНрд╖рд╛рддреНрдХрд╛рд░ рдореЗрдВ рдорджрдж рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдпрд╣рд╛рдВ рд╣реВрдВред",
            "bn": "ржиржорж╕рзНржХрж╛рж░! TalentScout-ржП рж╕рзНржмрж╛ржЧрждржоред ржЖржорж┐ ржЖржкржирж╛рж░ ржкрзНрж░рж╛ржержорж┐ржХ рж╕рзНржХрзНрж░рж┐ржирж┐ржВ ржЗржирзНржЯрж╛рж░ржнрж┐ржЙрждрзЗ рж╕рж╛рж╣рж╛ржпрзНржп ржХрж░рж╛рж░ ржЬржирзНржп ржПржЦрж╛ржирзЗ ржЖржЫрж┐ред",
            "ta": "ро╡рогроХрпНроХроорпН! TalentScout-роХрпНроХрпБ ро╡ро░ро╡рпЗро▒рпНроХро┐ро▒рпЛроорпН. роиро╛ройрпН роЙроЩрпНроХро│рпН роЖро░роорпНрок родрпЗро░рпНро╡рпБ роирпЗро░рпНроХро╛рогро▓ро┐ро▓рпН роЙродро╡ роЗроЩрпНроХрпЗ роЗро░рпБроХрпНроХро┐ро▒рпЗройрпН.",
            "te": "р░ир░ор░╕р▒Нр░Хр░╛р░░р░В! TalentScout р░Хр░┐ р░╕р▒Нр░╡р░╛р░Чр░др░В. р░ир▒Зр░ир▒Б р░ор▒А р░кр▒Нр░░р░╛р░░р░Вр░н р░╕р▒Нр░Хр▒Нр░░р▒Ар░ир░┐р░Вр░Чр▒Н р░Зр░Вр░Яр░░р▒Нр░╡р▒Нр░пр▒Вр░▓р▒Л р░╕р░╣р░╛р░пр░В р░Ър▒Зр░пр░бр░╛р░ир░┐р░Хр░┐ р░Зр░Хр▒Нр░Хр░б р░Йр░ир▒Нр░ир░╛р░ир▒Б.",
            "mr": "рдирдорд╕реНрдХрд╛рд░! TalentScout рдордзреНрдпреЗ рдЖрдкрд▓реЗ рд╕реНрд╡рд╛рдЧрдд рдЖрд╣реЗ. рдореА рддреБрдордЪреНрдпрд╛ рдкреНрд░рд╛рд░рдВрднрд┐рдХ рд╕реНрдХреНрд░реАрдирд┐рдВрдЧ рдореБрд▓рд╛рдЦрддреАрдд рдорджрдд рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдпреЗрдереЗ рдЖрд╣реЗ.",
            "gu": "ркиркорк╕рлНркдрлЗ! TalentScout ркорк╛ркВ ркЖрккркирлБркВ рк╕рлНрк╡рк╛ркЧркд ркЫрлЗ. рк╣рлБркВ ркдркорк╛рк░рлА рккр▒Нрк░рк╛рк░ркВркнрк┐ркХ рк╕р▒НркХр▒Нрк░р▒Аркирк┐ркВркЧ ркЗркир▒НркЯрк░рк╡рлНркпрлВркорк╛ркВ ркоркжркж ркХрк░рк╡рк╛ ркорк╛ркЯрлЗ ркЕрк╣рлАркВ ркЫрлБркВ.",
            "kn": "р▓ир▓ор▓╕р│Нр▓Хр▓╛р▓░! TalentScout р▓Чр│Ж р▓╕р│Бр▓╕р│Нр▓╡р▓╛р▓Чр▓д. р▓ир▓╛р▓ир│Б р▓ир▓┐р▓ор│Нр▓о р▓Жр▓░р▓Вр▓нр▓┐р▓Х р▓╕р│Нр▓Хр│Нр▓░р│Ар▓ир▓┐р▓Вр▓Чр│Н р▓╕р▓Вр▓жр▓░р│Нр▓╢р▓ир▓жр▓▓р│Нр▓▓р▓┐ р▓╕р▓╣р▓╛р▓п р▓ор▓╛р▓бр▓▓р│Б р▓Зр▓▓р│Нр▓▓р▓┐ р▓Зр▓жр│Нр▓жр│Зр▓ир│Ж.",
            "ml": "р┤ир┤ор┤╕р╡Нр┤Хр┤╛р┤░р┤В! TalentScout-р┤▓р╡Зр┤Хр╡Нр┤Хр╡Н р┤╕р╡Нр┤╡р┤╛р┤Чр┤др┤В. р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤кр╡Нр┤░р┤╛р┤░р┤Вр┤н р┤╕р╡Нр┤Хр╡Нр┤░р╡Ар┤ир┤┐р┤Вр┤Чр╡Н р┤Зр┤ир╡Нр┤▒р╡╝р┤╡р╡Нр┤пр╡Вр┤╡р┤┐р╡╜ р┤╕р┤╣р┤╛р┤пр┤┐р┤Хр╡Нр┤Хр┤╛р╡╗ р┤Юр┤╛р╡╗ р┤Зр┤╡р┤┐р┤Яр╡Жр┤пр╡Бр┤гр╡Нр┤Яр╡Н.",
            "pa": "ри╕рид ри╕рйНри░рйА риЕриХри╛ри▓! TalentScout ри╡ри┐рй▒риЪ ридрйБри╣ри╛рибри╛ ри╕ри╡ри╛риЧрид ри╣рйИред риорйИриВ ридрйБри╣ри╛рибрйА ри╕ри╝рйБри░рйВриЖридрйА ри╕риХрйНри░рйАриири┐рй░риЧ риЗрй░риЯри░ри╡ри┐риК ри╡ри┐рй▒риЪ риорижриж риХри░рии ри▓риИ риЗрй▒риерйЗ ри╣ри╛риВред",
            "ur": "╪з┘Д╪│┘Д╪з┘Е ╪╣┘Д█М┌й┘Е! TalentScout ┘Е█М┌║ ╪в┘╛ ┌й╪з ╪о█М╪▒ ┘Е┘В╪п┘Е █Б█Т█Ф ┘Е█М┌║ ╪в┘╛ ┌й█М ╪з╪и╪к╪п╪з╪ж█М ╪з╪│┌й╪▒█М┘Ж┘Ж┌п ╪з┘Ж┘╣╪▒┘И█М┘И ┘Е█М┌║ ┘Е╪п╪п ┌й╪▒┘Ж█Т ┌й█Т ┘Д█М█Т █М█Б╪з┌║ █Б┘И┌║█Ф",
            "ar": "┘Е╪▒╪н╪и╪з! ╪г┘З┘Д╪з ┘И╪│┘З┘Д╪з ╪и┘Г ┘Б┘К TalentScout. ╪г┘Ж╪з ┘З┘Ж╪з ┘Д┘Е╪│╪з╪╣╪п╪к┘Г ┘Б┘К ┘Е┘В╪з╪и┘Д╪й ╪з┘Д┘Б╪н╪╡ ╪з┘Д╪г┘И┘Д┘К."
        }
        
        return greetings.get(language_code, greetings["en"])
    
    def get_language_selector_prompt(self) -> str:
        """
        Get a prompt for language selection.
        
        Returns:
            Language selection prompt
        """
        prompt = "Please select your preferred language for this interview:\n\n"
        
        for code, info in self.SUPPORTED_LANGUAGES.items():
            prompt += f"{info['flag']} {info['native_name']} ({info['name']}) - Type '{code}'\n"
        
        prompt += "\nOr simply start typing in your preferred language and I'll detect it automatically."
        
        return prompt
    
    def update_language_preference(self, session_id: str, language_code: str) -> None:
        """
        Update language preference for a specific session.
        
        Args:
            session_id: Session identifier
            language_code: Preferred language code
        """
        self.language_preferences[session_id] = language_code
    
    def get_session_language(self, session_id: str) -> str:
        """
        Get the preferred language for a specific session.
        
        Args:
            session_id: Session identifier
            
        Returns:
            Language code for the session
        """
        return self.language_preferences.get(session_id, "en")
    
    def auto_switch_language(self, text: str, current_language: str, session_id: str = None) -> Tuple[str, bool, str]:
        """
        Automatically switch language based on user input with confidence thresholds.
        
        Args:
            text: User input text to analyze
            current_language: Current conversation language
            session_id: Optional session ID for preference tracking
            
        Returns:
            Tuple of (new_language, switched, message) where:
            - new_language: The language to use (may be same as current)
            - switched: Boolean indicating if language was switched
            - message: Optional message to show user about language change
        """
        if not text or not text.strip():
            return current_language, False, ""
        
        # Detect language with confidence
        detected_language, confidence = self.detect_language_with_confidence(text)
        
        # If detected language is the same as current, no switch needed
        if detected_language == current_language:
            return current_language, False, ""
        
        # High confidence threshold - automatic switch
        if confidence >= 0.7:
            if session_id:
                self.update_language_preference(session_id, detected_language)
            
            lang_info = self.get_language_info(detected_language)
            lang_name = lang_info['native_name'] if lang_info else detected_language
            
            message = f"ЁЯМН Language automatically switched to {lang_name} (confidence: {confidence:.1%})"
            return detected_language, True, message
        
        # Medium confidence threshold - ask for confirmation
        elif confidence >= 0.5:
            lang_info = self.get_language_info(detected_language)
            lang_name = lang_info['native_name'] if lang_info else detected_language
            
            message = f"ЁЯдФ I detected you might be speaking {lang_name}. Would you like to switch to this language? (confidence: {confidence:.1%})"
            return current_language, False, message
        
        # Low confidence - stay with current language
        else:
            return current_language, False, ""
    
    def confirm_language_switch(self, target_language: str, session_id: str = None) -> Tuple[str, str]:
        """
        Confirm and execute a language switch.
        
        Args:
            target_language: Language to switch to
            session_id: Optional session ID for preference tracking
            
        Returns:
            Tuple of (new_language, confirmation_message)
        """
        if target_language not in self.SUPPORTED_LANGUAGES:
            return self.current_language, f"тЭМ Language '{target_language}' is not supported."
        
        # Update preferences
        if session_id:
            self.update_language_preference(session_id, target_language)
        
        self.current_language = target_language
        
        lang_info = self.get_language_info(target_language)
        lang_name = lang_info['native_name'] if lang_info else target_language
        
        # Get localized confirmation message
        confirmation_message = self.get_localized_greeting(target_language)
        
        return target_language, f"тЬЕ Language switched to {lang_name}!\n\n{confirmation_message}"
    
    def get_language_switch_suggestions(self, text: str, current_language: str) -> List[Tuple[str, float]]:
        """
        Get language switch suggestions based on input text.
        
        Args:
            text: Input text to analyze
            current_language: Current conversation language
            
        Returns:
            List of (language_code, confidence) tuples sorted by confidence
        """
        if not text or not text.strip():
            return []
        
        text_lower = text.lower().strip()
        language_scores = {}
        
        # Score each language based on pattern matches
        for lang_code, patterns in self.LANGUAGE_PATTERNS.items():
            if lang_code == current_language:
                continue  # Skip current language
                
            score = 0
            unique_matches = set()
            
            for pattern in patterns:
                matches = re.findall(pattern, text_lower, re.IGNORECASE)
                for match in matches:
                    unique_matches.add(match)
            
            if unique_matches:
                # Calculate basic confidence
                text_length = len(text_lower.split())
                length_factor = min(1.0, text_length / 5.0)
                strength_factor = min(1.0, len(unique_matches) / 3.0)
                confidence = strength_factor * length_factor
                
                if confidence > 0.1:  # Only include meaningful suggestions
                    language_scores[lang_code] = confidence
        
        # Sort by confidence descending
        suggestions = sorted(language_scores.items(), key=lambda x: x[1], reverse=True)
        return suggestions[:3]  # Return top 3 suggestions
    
    def get_cultural_context(self, language: str) -> Dict[str, Any]:
        """
        Get cultural context information for a specific language.
        
        Args:
            language: Language code
            
        Returns:
            Dictionary containing cultural context information
        """
        cultural_contexts = {
            "en": {
                "greeting_style": "casual_professional",
                "formality_level": "medium",
                "name_format": "first_last",
                "phone_format": "+1-XXX-XXX-XXXX",
                "date_format": "MM/DD/YYYY",
                "time_format": "12_hour",
                "currency": "USD",
                "professional_titles": ["Mr.", "Ms.", "Dr.", "Prof."],
                "communication_style": "direct",
                "interview_expectations": "punctual, prepared, confident"
            },
            "es": {
                "greeting_style": "warm_professional",
                "formality_level": "high",
                "name_format": "first_paternal_maternal",
                "phone_format": "+XX-XXX-XXX-XXXX",
                "date_format": "DD/MM/YYYY",
                "time_format": "24_hour",
                "currency": "EUR/USD/local",
                "professional_titles": ["Sr.", "Sra.", "Dr.", "Ing."],
                "communication_style": "relationship_focused",
                "interview_expectations": "respectful, family_context_ok, relationship_building"
            },
            "fr": {
                "greeting_style": "formal_professional",
                "formality_level": "high",
                "name_format": "first_last",
                "phone_format": "+33-X-XX-XX-XX-XX",
                "date_format": "DD/MM/YYYY",
                "time_format": "24_hour",
                "currency": "EUR",
                "professional_titles": ["M.", "Mme.", "Dr.", "Prof."],
                "communication_style": "formal_structured",
                "interview_expectations": "formal, well_prepared, intellectual_discussion"
            },
            "de": {
                "greeting_style": "formal_professional",
                "formality_level": "high",
                "name_format": "first_last",
                "phone_format": "+49-XXX-XXXXXXX",
                "date_format": "DD.MM.YYYY",
                "time_format": "24_hour",
                "currency": "EUR",
                "professional_titles": ["Herr", "Frau", "Dr.", "Prof."],
                "communication_style": "direct_structured",
                "interview_expectations": "punctual, thorough, technical_competence"
            },
            "it": {
                "greeting_style": "warm_professional",
                "formality_level": "medium_high",
                "name_format": "first_last",
                "phone_format": "+39-XXX-XXX-XXXX",
                "date_format": "DD/MM/YYYY",
                "time_format": "24_hour",
                "currency": "EUR",
                "professional_titles": ["Sig.", "Sig.ra", "Dott.", "Prof."],
                "communication_style": "expressive_professional",
                "interview_expectations": "personable, passionate, competent"
            },
            "pt": {
                "greeting_style": "warm_professional",
                "formality_level": "medium_high",
                "name_format": "first_last",
                "phone_format": "+55-XX-XXXXX-XXXX",
                "date_format": "DD/MM/YYYY",
                "time_format": "24_hour",
                "currency": "BRL/EUR",
                "professional_titles": ["Sr.", "Sra.", "Dr.", "Prof."],
                "communication_style": "relationship_focused",
                "interview_expectations": "friendly, competent, team_oriented"
            },
            "ru": {
                "greeting_style": "formal_professional",
                "formality_level": "high",
                "name_format": "first_patronymic_last",
                "phone_format": "+7-XXX-XXX-XX-XX",
                "date_format": "DD.MM.YYYY",
                "time_format": "24_hour",
                "currency": "RUB",
                "professional_titles": ["╨У╨╛╤Б╨┐╨╛╨┤╨╕╨╜", "╨У╨╛╤Б╨┐╨╛╨╢╨░", "╨Ф╨╛╨║╤В╨╛╤А"],
                "communication_style": "formal_hierarchical",
                "interview_expectations": "respectful, well_prepared, technical_depth"
            },
            "zh": {
                "greeting_style": "respectful_professional",
                "formality_level": "high",
                "name_format": "family_first",
                "phone_format": "+86-XXX-XXXX-XXXX",
                "date_format": "YYYY/MM/DD",
                "time_format": "24_hour",
                "currency": "CNY",
                "professional_titles": ["хЕИчФЯ", "хе│хгл", "хНЪхгл", "цХЩцОИ"],
                "communication_style": "hierarchical_respectful",
                "interview_expectations": "humble, prepared, respect_for_authority"
            },
            "ja": {
                "greeting_style": "very_formal_professional",
                "formality_level": "very_high",
                "name_format": "family_first",
                "phone_format": "+81-XX-XXXX-XXXX",
                "date_format": "YYYY/MM/DD",
                "time_format": "24_hour",
                "currency": "JPY",
                "professional_titles": ["уБХуВУ", "цзШ", "хНЪхгл", "цХЩцОИ"],
                "communication_style": "extremely_polite",
                "interview_expectations": "extremely_polite, humble, group_harmony"
            },
            "ko": {
                "greeting_style": "respectful_professional",
                "formality_level": "high",
                "name_format": "family_first",
                "phone_format": "+82-XX-XXXX-XXXX",
                "date_format": "YYYY.MM.DD",
                "time_format": "24_hour",
                "currency": "KRW",
                "professional_titles": ["ьФи", "ыЛШ", "ы░ХьВм", "ъ╡РьИШ"],
                "communication_style": "hierarchical_respectful",
                "interview_expectations": "respectful, age_hierarchy_aware, team_oriented"
            },
            "hi": {
                "greeting_style": "respectful_warm",
                "formality_level": "medium_high",
                "name_format": "first_last",
                "phone_format": "+91-XXXXX-XXXXX",
                "date_format": "DD/MM/YYYY",
                "time_format": "12_hour",
                "currency": "INR",
                "professional_titles": ["рд╢реНрд░реА", "рд╢реНрд░реАрдорддреА", "рдбреЙ.", "рдкреНрд░реЛ."],
                "communication_style": "respectful_relationship_focused",
                "interview_expectations": "respectful, family_context_ok, educational_background"
            },
            "ar": {
                "greeting_style": "formal_respectful",
                "formality_level": "high",
                "name_format": "first_father_family",
                "phone_format": "+XXX-X-XXX-XXXX",
                "date_format": "DD/MM/YYYY",
                "time_format": "12_hour",
                "currency": "local",
                "professional_titles": ["╪з┘Д╪│┘К╪п", "╪з┘Д╪│┘К╪п╪й", "╪з┘Д╪п┘Г╪к┘И╪▒", "╪з┘Д╪г╪│╪к╪з╪░"],
                "communication_style": "formal_respectful",
                "interview_expectations": "respectful, religious_considerations, family_context"
            }
        }
        
        # Default context for languages not specifically defined
        default_context = {
            "greeting_style": "professional",
            "formality_level": "medium",
            "name_format": "first_last",
            "phone_format": "international",
            "date_format": "DD/MM/YYYY",
            "time_format": "24_hour",
            "currency": "local",
            "professional_titles": ["Mr.", "Ms.", "Dr."],
            "communication_style": "professional",
            "interview_expectations": "professional, competent, prepared"
        }
        
        return cultural_contexts.get(language, default_context)
    
    def adapt_greeting_for_culture(self, language: str, base_greeting: str) -> str:
        """
        Adapt a greeting based on cultural context.
        
        Args:
            language: Target language code
            base_greeting: Base greeting message
            
        Returns:
            Culturally adapted greeting
        """
        context = self.get_cultural_context(language)
        
        # Add cultural adaptations based on greeting style
        if context["greeting_style"] == "very_formal_professional":
            return f"ЁЯЩП {base_greeting}\n\nI will conduct this interview with the utmost respect and professionalism."
        elif context["greeting_style"] == "formal_professional":
            return f"ЁЯдЭ {base_greeting}\n\nI look forward to learning about your professional background."
        elif context["greeting_style"] == "warm_professional":
            return f"ЁЯШК {base_greeting}\n\nI'm excited to learn about you and your experience!"
        elif context["greeting_style"] == "respectful_warm":
            return f"ЁЯЩП {base_greeting}\n\nI hope you and your family are doing well. Let's begin our conversation."
        elif context["greeting_style"] == "respectful_professional":
            return f"ЁЯЩП {base_greeting}\n\nThank you for taking the time to speak with me today."
        else:  # casual_professional or default
            return f"ЁЯСЛ {base_greeting}\n\nLet's get started with your interview!"
    
    def validate_cultural_data_format(self, data_type: str, value: str, language: str) -> Tuple[bool, str]:
        """
        Validate data format based on cultural context.
        
        Args:
            data_type: Type of data (name, phone, etc.)
            value: Value to validate
            language: Language/culture context
            
        Returns:
            Tuple of (is_valid, error_message)
        """
        context = self.get_cultural_context(language)
        
        if data_type == "name":
            return self._validate_name_format(value, context)
        elif data_type == "phone":
            return self._validate_phone_format(value, context)
        elif data_type == "date":
            return self._validate_date_format(value, context)
        else:
            return True, ""
    
    def _validate_name_format(self, name: str, context: Dict) -> Tuple[bool, str]:
        """Validate name format based on cultural context."""
        if not name or not name.strip():
            return False, "Name cannot be empty"
        
        name_parts = name.strip().split()
        
        if context["name_format"] == "first_last":
            if len(name_parts) < 2:
                return False, "Please provide both first and last name"
        elif context["name_format"] == "first_paternal_maternal":
            if len(name_parts) < 2:
                return False, "Please provide at least first name and paternal surname"
        elif context["name_format"] == "family_first":
            if len(name_parts) < 2:
                return False, "Please provide both family and given name"
        elif context["name_format"] == "first_patronymic_last":
            if len(name_parts) < 2:
                return False, "Please provide at least first and last name"
        
        return True, ""
    
    def _validate_phone_format(self, phone: str, context: Dict) -> Tuple[bool, str]:
        """Validate phone format based on cultural context."""
        if not phone or not phone.strip():
            return False, "Phone number cannot be empty"
        
        # Basic validation - contains digits and common phone characters
        phone_clean = re.sub(r'[^\d+\-\s\(\)]', '', phone)
        if len(phone_clean) < 7:
            return False, f"Phone number seems too short. Expected format: {context['phone_format']}"
        
        return True, ""
    
    def _validate_date_format(self, date: str, context: Dict) -> Tuple[bool, str]:
        """Validate date format based on cultural context."""
        if not date or not date.strip():
            return False, "Date cannot be empty"
        
        # Basic date validation
        date_patterns = {
            "DD/MM/YYYY": r'\d{1,2}/\d{1,2}/\d{4}',
            "MM/DD/YYYY": r'\d{1,2}/\d{1,2}/\d{4}',
            "YYYY/MM/DD": r'\d{4}/\d{1,2}/\d{1,2}',
            "DD.MM.YYYY": r'\d{1,2}\.\d{1,2}\.\d{4}',
            "YYYY.MM.DD": r'\d{4}\.\d{1,2}\.\d{1,2}'
        }
        
        expected_format = context["date_format"]
        pattern = date_patterns.get(expected_format, r'\d{1,2}[/\-.]\d{1,2}[/\-.]\d{4}')
        
        if not re.match(pattern, date.strip()):
            return False, f"Date format should be {expected_format}"
        
        return True, "" 